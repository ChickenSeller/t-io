package org.tio.core.task;

import java.nio.channels.AsynchronousSocketChannel;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.tio.core.ChannelContext;
import org.tio.core.GroupContext;
import org.tio.core.ReconnConf;
import org.tio.core.intf.AioListener;
import org.tio.core.intf.Packet;
import org.tio.core.maintain.MaintainUtils;
import org.tio.core.threadpool.AbstractSynRunnable;
import org.tio.core.utils.SystemTimer;

/**
 * 
 * @author tanyaowu 
 * @创建时间 2016年11月19日 下午1:44:39
 *
 * @操作列表
 *  编号	| 操作时间	| 操作人员	 | 操作说明
 *  (1) | 2016年11月19日 | tanyaowu | 新建类
 *
 */
public class CloseRunnable<SessionContext, P extends Packet, R> extends AbstractSynRunnable
{
	private static Logger log = LoggerFactory.getLogger(CloseRunnable.class);

	private ChannelContext<SessionContext, P, R> channelContext;
	private String remark;
	private Throwable throwable;
	private boolean isRemove = false;
	private boolean isWaitingExecute = false;
	private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
	private static final AtomicLong closeCount = new AtomicLong();//总的关闭次数

	public CloseRunnable(ChannelContext<SessionContext, P, R> channelContext, Throwable t, String remark, Executor executor)
	{
		super(executor);
		this.channelContext = channelContext;
		this.throwable = t;
		this.remark = remark;
	}

	@Override
	public void runTask()
	{
		closeCount.incrementAndGet();
		if (throwable != null)
		{
			log.error("第{}次关闭连接:{},{}", closeCount.get(), channelContext.toString(), remark);
		} else
		{
			log.info("第{}次关闭连接:{},{}", closeCount.get(), channelContext.toString(), remark);
		}

		GroupContext<SessionContext, P, R> groupContext = channelContext.getGroupContext();
		AioListener<SessionContext, P, R> aioListener = groupContext.getAioListener();

		ReconnConf<SessionContext, P, R> reconnConf = channelContext.getGroupContext().getReconnConf();
		if (!isRemove)
		{
			if (reconnConf != null && reconnConf.getInterval() > 0)
			{
				if (reconnConf.getRetryCount() <= 0 || reconnConf.getRetryCount() >= channelContext.getReconnCount())
				{
					//需要重连，所以并不删除
				} else
				{
					isRemove = true;
				}
			} else
			{
				isRemove = true;
			}
		}

		try
		{
			channelContext.setClosed(true);
			channelContext.getGroupContext().getGroupStat().getClosed().incrementAndGet();
			channelContext.getStat().setTimeClosed(SystemTimer.currentTimeMillis());

			if (isRemove)
			{
				MaintainUtils.removeFromMaintain(channelContext);
				channelContext.setRemoved(true);
			} else
			{
				groupContext.getCloseds().add(channelContext);
				groupContext.getConnecteds().remove(channelContext);
				try
				{
					reconnConf.getQueue().put(channelContext);
				} catch (Exception e)
				{
					log.error(e.toString(), e);
				}
			}
			
			try
			{
				AsynchronousSocketChannel asynchronousSocketChannel = channelContext.getAsynchronousSocketChannel();
				if (asynchronousSocketChannel != null)
				{
					if (asynchronousSocketChannel.isOpen())
					{
						try
						{
							asynchronousSocketChannel.shutdownInput();
							asynchronousSocketChannel.shutdownOutput();
						} catch (Exception e)
						{
							log.error(e.toString(), e);
						}
						asynchronousSocketChannel.close();
					}
				}
			} catch (Throwable e)
			{
				log.error(e.toString());
			}
			
			try
			{
				aioListener.onAfterClose(channelContext, throwable, remark, isRemove);
			} catch (Throwable e)
			{
				log.error(e.toString(), e);
			}
		} catch (Throwable e)
		{
			log.error(e.toString(), e);
		} finally
		{
			if (!isRemove)
			{
				this.setWaitingExecute(false);
			}
		}
	}

	@Override
	public boolean isNeededExecute()
	{
		return false;
	}

	/**
	 * @return the channelContext
	 */
	public ChannelContext<SessionContext, P, R> getChannelContext()
	{
		return channelContext;
	}

	/**
	 * @return the remark
	 */
	public String getRemark()
	{
		return remark;
	}

	/**
	 * @param remark the remark to set
	 */
	public void setRemark(String remark)
	{
		this.remark = remark;
	}

	/**
	 * @return the t
	 */
	public Throwable getThrowable()
	{
		return throwable;
	}

	/**
	 * @param t the t to set
	 */
	public void setThrowable(Throwable throwable)
	{
		this.throwable = throwable;
	}

	@Override
	public String toString()
	{
		StringBuilder builder = new StringBuilder();
		builder.append(this.getClass().getSimpleName()).append(":");
		builder.append(channelContext.toString());
		return builder.toString();
	}

	/**
	 * @return the isWaitingExecute
	 */
	public boolean isWaitingExecute()
	{
		return isWaitingExecute;
	}

	/**
	 * @param isWaitingExecute the isWaitingExecute to set
	 */
	public void setWaitingExecute(boolean isWaitingExecute)
	{
		this.isWaitingExecute = isWaitingExecute;
	}

	/**
	 * @return the isRemove
	 */
	public boolean isRemove()
	{
		return isRemove;
	}

	/**
	 * @param isRemove the isRemove to set
	 */
	public void setRemove(boolean isRemove)
	{
		this.isRemove = isRemove;
	}

	/**
	 * @return the lock
	 */
	public ReentrantReadWriteLock getLock()
	{
		return lock;
	}

}
